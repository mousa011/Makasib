{"id":"eKWW","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/package.json","includedInParent":true,"mtime":499162500000},{"name":"./config.js","loc":{"line":3,"column":23},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/plugin.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/config.js"},{"name":"./util.js","loc":{"line":4,"column":21},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/plugin.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/util.js"},{"name":"process","parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/plugin.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"generated":{"js":"var $eKWW$exports = function () {\n  var exports = this;\n  var module = {\n    exports: this\n  };\n  var process = $parcel$require(\"eKWW\", \"process\");\n  const config = $parcel$require(\"eKWW\", \"./config.js\");\n  const util = $parcel$require(\"eKWW\", \"./util.js\");\n  module.exports = {\n    name: 'rtlcss',\n    priority: 100,\n    directives: {\n      control: {\n        ignore: {\n          expect: {\n            atrule: true,\n            comment: true,\n            decl: true,\n            rule: true\n          },\n          endNode: null,\n\n          begin(node, metadata, context) {\n            // find the ending node in case of self closing directive\n            if (!this.endNode && metadata.begin && metadata.end) {\n              let n = node;\n\n              while (n && n.nodes) {\n                n = n.nodes[n.nodes.length - 1];\n              }\n\n              this.endNode = n;\n            }\n\n            let prevent = true;\n\n            if (node.type === 'comment' && node.text.match(/^\\s*!?\\s*rtl:end:ignore/)) {\n              prevent = false;\n            }\n\n            return prevent;\n          },\n\n          end(node, metadata, context) {\n            // end if:\n            //  1. block directive and the node is comment\n            //  2. self closing directive and node is endNode\n            if (metadata.begin !== metadata.end && node.type === 'comment' || metadata.begin && metadata.end && node === this.endNode) {\n              // clear ending node\n              this.endNode = null;\n              return true;\n            }\n\n            return false;\n          }\n\n        },\n        rename: {\n          expect: {\n            rule: true\n          },\n\n          begin(node, metadata, context) {\n            node.selector = context.util.applyStringMap(node.selector, false);\n            return false;\n          },\n\n          end(node, context) {\n            return true;\n          }\n\n        },\n        raw: {\n          expect: {\n            self: true\n          },\n\n          begin(node, metadata, context) {\n            const nodes = context.postcss.parse(metadata.param, {\n              from: node.source.input.from\n            });\n            nodes.walk(node => {\n              node[context.symbol] = true;\n            });\n            node.parent.insertBefore(node, nodes);\n            return true;\n          },\n\n          end(node, context) {\n            return true;\n          }\n\n        },\n        remove: {\n          expect: {\n            atrule: true,\n            rule: true,\n            decl: true\n          },\n\n          begin(node, metadata, context) {\n            let prevent = false;\n\n            switch (node.type) {\n              case 'atrule':\n              case 'rule':\n              case 'decl':\n                prevent = true;\n                node.remove();\n            }\n\n            return prevent;\n          },\n\n          end(node, metadata, context) {\n            return true;\n          }\n\n        },\n        options: {\n          expect: {\n            self: true\n          },\n          stack: [],\n\n          begin(node, metadata, context) {\n            this.stack.push(util.extend({}, context.config));\n            let options;\n\n            try {\n              options = JSON.parse(metadata.param);\n            } catch (e) {\n              throw node.error('Invalid options object', {\n                details: e\n              });\n            }\n\n            context.config = config.configure(options, context.config.plugins);\n            context.util = util.configure(context.config);\n            return true;\n          },\n\n          end(node, metadata, context) {\n            const config = this.stack.pop();\n\n            if (config && !metadata.begin) {\n              context.config = config;\n              context.util = util.configure(context.config);\n            }\n\n            return true;\n          }\n\n        },\n        config: {\n          expect: {\n            self: true\n          },\n          stack: [],\n\n          begin(node, metadata, context) {\n            this.stack.push(util.extend({}, context.config));\n            let configuration;\n\n            try {\n              configuration = eval(`(${metadata.param})`); // eslint-disable-line no-eval\n            } catch (e) {\n              throw node.error('Invalid config object', {\n                details: e\n              });\n            }\n\n            context.config = config.configure(configuration.options, configuration.plugins);\n            context.util = util.configure(context.config);\n            return true;\n          },\n\n          end(node, metadata, context) {\n            const config = this.stack.pop();\n\n            if (config && !metadata.begin) {\n              context.config = config;\n              context.util = util.configure(context.config);\n            }\n\n            return true;\n          }\n\n        }\n      },\n      value: [{\n        name: 'ignore',\n\n        action(decl, expr, context) {\n          return true;\n        }\n\n      }, {\n        name: 'prepend',\n\n        action(decl, expr, context) {\n          let prefix = '';\n          const hasRawValue = decl.raws.value && decl.raws.value.raw;\n          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : ''}`;\n          raw.replace(expr, (m, v) => {\n            prefix += v;\n          });\n          decl.value = hasRawValue ? decl.raws.value.raw = prefix + decl.raws.value.raw : prefix + decl.value;\n          return true;\n        }\n\n      }, {\n        name: 'append',\n\n        action(decl, expr, context) {\n          let suffix = '';\n          const hasRawValue = decl.raws.value && decl.raws.value.raw;\n          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : ''}`;\n          raw.replace(expr, (m, v) => {\n            suffix = v + suffix;\n          });\n          decl.value = hasRawValue ? decl.raws.value.raw += suffix : decl.value + suffix;\n          return true;\n        }\n\n      }, {\n        name: 'insert',\n\n        action(decl, expr, context) {\n          const hasRawValue = decl.raws.value && decl.raws.value.raw;\n          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : ''}`;\n          const result = raw.replace(expr, (match, value) => hasRawValue ? value + match : value);\n          decl.value = hasRawValue ? decl.raws.value.raw = result : result;\n          return true;\n        }\n\n      }, {\n        name: '',\n\n        action(decl, expr, context) {\n          const hasRawValue = decl.raws.value && decl.raws.value.raw;\n          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : ''}${decl.important ? decl.raws.important.substr(9).trim() : ''}`;\n          raw.replace(expr, (match, value) => {\n            decl.value = hasRawValue ? decl.raws.value.raw = value + match : value;\n          });\n          return true;\n        }\n\n      }]\n    },\n    processors: [{\n      name: 'variable',\n      expr: /^--/im,\n\n      action(prop, value) {\n        return {\n          prop,\n          value\n        };\n      }\n\n    }, {\n      name: 'direction',\n      expr: /direction/im,\n\n      action(prop, value, context) {\n        return {\n          prop,\n          value: context.util.swapLtrRtl(value)\n        };\n      }\n\n    }, {\n      name: 'left',\n      expr: /left/im,\n\n      action(prop, value, context) {\n        return {\n          prop: prop.replace(this.expr, () => 'right'),\n          value\n        };\n      }\n\n    }, {\n      name: 'right',\n      expr: /right/im,\n\n      action(prop, value, context) {\n        return {\n          prop: prop.replace(this.expr, () => 'left'),\n          value\n        };\n      }\n\n    }, {\n      name: 'four-value syntax',\n      expr: /^(margin|padding|border-(color|style|width))$/ig,\n      cache: null,\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            match: /[^\\s\\uFFFD]+/g\n          };\n        }\n\n        const state = context.util.guardFunctions(value);\n        const result = state.value.match(this.cache.match);\n\n        if (result && result.length === 4 && (state.store.length > 0 || result[1] !== result[3])) {\n          let i = 0;\n          state.value = state.value.replace(this.cache.match, () => result[(4 - i++) % 4]);\n        }\n\n        return {\n          prop,\n          value: context.util.unguardFunctions(state)\n        };\n      }\n\n    }, {\n      name: 'border radius',\n      expr: /border-radius/ig,\n      cache: null,\n\n      flip(value) {\n        const parts = value.match(this.cache.match);\n        let i;\n\n        if (parts) {\n          switch (parts.length) {\n            case 2:\n              i = 1;\n\n              if (parts[0] !== parts[1]) {\n                value = value.replace(this.cache.match, () => parts[i--]);\n              }\n\n              break;\n\n            case 3:\n              // preserve leading whitespace.\n              value = value.replace(this.cache.white, m => `${m + parts[1]} `);\n              break;\n\n            case 4:\n              i = 0;\n\n              if (parts[0] !== parts[1] || parts[2] !== parts[3]) {\n                value = value.replace(this.cache.match, () => parts[(5 - i++) % 4]);\n              }\n\n              break;\n          }\n        }\n\n        return value;\n      },\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            match: /[^\\s\\uFFFD]+/g,\n            slash: /[^/]+/g,\n            white: /(^\\s*)/\n          };\n        }\n\n        const state = context.util.guardFunctions(value);\n        state.value = state.value.replace(this.cache.slash, m => this.flip(m));\n        return {\n          prop,\n          value: context.util.unguardFunctions(state)\n        };\n      }\n\n    }, {\n      name: 'shadow',\n      expr: /shadow/ig,\n      cache: null,\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            replace: /[^,]+/g\n          };\n        }\n\n        const colorSafe = context.util.guardHexColors(value);\n        const funcSafe = context.util.guardFunctions(colorSafe.value);\n        funcSafe.value = funcSafe.value.replace(this.cache.replace, m => context.util.negate(m));\n        colorSafe.value = context.util.unguardFunctions(funcSafe);\n        return {\n          prop,\n          value: context.util.unguardHexColors(colorSafe)\n        };\n      }\n\n    }, {\n      name: 'transform and perspective origin',\n      expr: /(?:transform|perspective)-origin/ig,\n      cache: null,\n\n      flip(value, context) {\n        if (value === '0') {\n          value = '100%';\n        } else if (value.match(this.cache.percent)) {\n          value = context.util.complement(value);\n        } else if (value.match(this.cache.length)) {\n          value = context.util.flipLength(value);\n        }\n\n        return value;\n      },\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            match: context.util.regex(['calc', 'percent', 'length'], 'g'),\n            percent: context.util.regex(['calc', 'percent'], 'i'),\n            length: context.util.regex(['length'], 'gi'),\n            xKeyword: /(left|right)/i\n          };\n        }\n\n        if (value.match(this.cache.xKeyword)) {\n          value = context.util.swapLeftRight(value);\n        } else {\n          const state = context.util.guardFunctions(value);\n          const parts = state.value.match(this.cache.match);\n\n          if (parts && parts.length > 0) {\n            parts[0] = this.flip(parts[0], context);\n            state.value = state.value.replace(this.cache.match, () => parts.shift());\n            value = context.util.unguardFunctions(state);\n          }\n        }\n\n        return {\n          prop,\n          value\n        };\n      }\n\n    }, {\n      name: 'transform',\n      expr: /^(?!text-).*?transform$/ig,\n      cache: null,\n\n      flip(value, process, context) {\n        let i = 0;\n        return value.replace(this.cache.unit, num => process(++i, num));\n      },\n\n      flipMatrix(value, context) {\n        return this.flip(value, (i, num) => {\n          if (i === 2 || i === 3 || i === 5) {\n            return context.util.negate(num);\n          }\n\n          return num;\n        }, context);\n      },\n\n      flipMatrix3D(value, context) {\n        return this.flip(value, (i, num) => {\n          if (i === 2 || i === 4 || i === 5 || i === 13) {\n            return context.util.negate(num);\n          }\n\n          return num;\n        }, context);\n      },\n\n      flipRotate3D(value, context) {\n        return this.flip(value, (i, num) => {\n          if (i === 1 || i === 4) {\n            return context.util.negate(num);\n          }\n\n          return num;\n        }, context);\n      },\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            negatable: /((translate)(x|3d)?|rotate(z|y)?)$/ig,\n            unit: context.util.regex(['calc', 'number'], 'g'),\n            matrix: /matrix$/i,\n            matrix3D: /matrix3d$/i,\n            skewXY: /skew(x|y)?$/i,\n            rotate3D: /rotate3d$/i\n          };\n        }\n\n        const state = context.util.guardFunctions(value);\n        return {\n          prop,\n          value: context.util.unguardFunctions(state, (v, n) => {\n            if (n.length) {\n              if (n.match(this.cache.matrix3D)) {\n                v = this.flipMatrix3D(v, context);\n              } else if (n.match(this.cache.matrix)) {\n                v = this.flipMatrix(v, context);\n              } else if (n.match(this.cache.rotate3D)) {\n                v = this.flipRotate3D(v, context);\n              } else if (n.match(this.cache.skewXY)) {\n                v = context.util.negateAll(v);\n              } else if (n.match(this.cache.negatable)) {\n                v = context.util.negate(v);\n              }\n            }\n\n            return v;\n          })\n        };\n      }\n\n    }, {\n      name: 'transition',\n      expr: /transition(-property)?$/i,\n\n      action(prop, value, context) {\n        return {\n          prop,\n          value: context.util.swapLeftRight(value)\n        };\n      }\n\n    }, {\n      name: 'background',\n      expr: /(background|object)(-position(-x)?|-image)?$/i,\n      cache: null,\n\n      flip(value, context) {\n        const state = util.saveTokens(value, true);\n        const parts = state.value.match(this.cache.match);\n\n        if (parts && parts.length > 0) {\n          const keywords = (state.value.match(this.cache.position) || '').length;\n\n          if (\n          /* edge offsets */\n          parts.length >= 3 ||\n          /* keywords only */\n          keywords === 2) {\n            state.value = util.swapLeftRight(state.value);\n          } else {\n            parts[0] = parts[0] === '0' ? '100%' : parts[0].match(this.cache.percent) ? context.util.complement(parts[0]) : parts[0].match(this.cache.length) ? context.util.flipLength(parts[0]) : context.util.swapLeftRight(parts[0]);\n            state.value = state.value.replace(this.cache.match, () => parts.shift());\n          }\n        }\n\n        return util.restoreTokens(state);\n      },\n\n      update(context, value, name) {\n        if (name.match(this.cache.gradient)) {\n          value = context.util.swapLeftRight(value);\n\n          if (value.match(this.cache.angle)) {\n            value = context.util.negate(value);\n          }\n        } else if ((context.config.processUrls === true || context.config.processUrls.decl === true) && name.match(this.cache.url)) {\n          value = context.util.applyStringMap(value, true);\n        }\n\n        return value;\n      },\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            match: context.util.regex(['position', 'percent', 'length', 'calc'], 'ig'),\n            percent: context.util.regex(['calc', 'percent'], 'i'),\n            position: context.util.regex(['position'], 'g'),\n            length: context.util.regex(['length'], 'gi'),\n            gradient: /gradient$/i,\n            angle: /\\d+(deg|g?rad|turn)/i,\n            url: /^url/i\n          };\n        }\n\n        const colorSafe = context.util.guardHexColors(value);\n        const funcSafe = context.util.guardFunctions(colorSafe.value);\n        const parts = funcSafe.value.split(',');\n        const lprop = prop.toLowerCase();\n\n        if (lprop !== 'background-image') {\n          for (let x = 0; x < parts.length; x++) {\n            parts[x] = this.flip(parts[x], context);\n          }\n        }\n\n        funcSafe.value = parts.join(',');\n        colorSafe.value = context.util.unguardFunctions(funcSafe, this.update.bind(this, context));\n        return {\n          prop,\n          value: context.util.unguardHexColors(colorSafe)\n        };\n      }\n\n    }, {\n      name: 'keyword',\n      expr: /float|clear|text-align/i,\n\n      action(prop, value, context) {\n        return {\n          prop,\n          value: context.util.swapLeftRight(value)\n        };\n      }\n\n    }, {\n      name: 'cursor',\n      expr: /cursor/i,\n      cache: null,\n\n      update(context, value, name) {\n        if ((context.config.processUrls === true || context.config.processUrls.decl === true) && name.match(this.cache.url)) {\n          value = context.util.applyStringMap(value, true);\n        }\n\n        return value;\n      },\n\n      flip(value) {\n        return value.replace(this.cache.replace, (s, m) => {\n          return s.replace(m, m.replace(this.cache.e, '*').replace(this.cache.w, 'e').replace(this.cache.star, 'w'));\n        });\n      },\n\n      action(prop, value, context) {\n        if (this.cache === null) {\n          this.cache = {\n            replace: /\\b(ne|nw|se|sw|nesw|nwse)-resize/ig,\n            url: /^url/i,\n            e: /e/i,\n            w: /w/i,\n            star: /\\*/i\n          };\n        }\n\n        const state = context.util.guardFunctions(value);\n        state.value = state.value.split(',').map(part => this.flip(part)).join(',');\n        return {\n          prop,\n          value: context.util.unguardFunctions(state, this.update.bind(this, context))\n        };\n      }\n\n    }]\n  };\n  return module.exports;\n}.call({});"},"sourceMaps":null,"error":null,"hash":"b87e01abe01bfee253570de2196620c9","cacheData":{"env":{},"imports":{"$require$./config.js":["./config.js","*"],"$require$./util.js":["./util.js","*"],"$require$process":["process","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true,"isES6Module":false}}