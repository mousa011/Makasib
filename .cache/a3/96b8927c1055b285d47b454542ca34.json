{"id":"YmdI","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/package.json","includedInParent":true,"mtime":499162500000},{"name":"postcss","loc":{"line":10,"column":24},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/rtlcss.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/postcss.js"},{"name":"./state.js","loc":{"line":11,"column":22},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/rtlcss.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/state.js"},{"name":"./config.js","loc":{"line":12,"column":23},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/rtlcss.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/config.js"},{"name":"./util.js","loc":{"line":13,"column":21},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/rtlcss.js","resolved":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/lib/util.js"}],"generated":{"js":"var $YmdI$exports = {};\nconst $YmdI$var$postcss = $parcel$require(\"YmdI\", \"postcss\");\nconst $YmdI$var$state = $parcel$require(\"YmdI\", \"./state.js\");\nconst $YmdI$var$config = $parcel$require(\"YmdI\", \"./config.js\");\nconst $YmdI$var$util = $parcel$require(\"YmdI\", \"./util.js\");\n\n$YmdI$exports = (options, plugins, hooks) => {\n  const processed = Symbol('processed');\n  const configuration = $YmdI$var$config.configure(options, plugins, hooks);\n  const context = {\n    // provides access to postcss\n    postcss: $YmdI$var$postcss,\n    // provides access to the current configuration\n    config: configuration,\n    // provides access to utilities object\n    util: $YmdI$var$util.configure(configuration),\n    // processed symbol\n    symbol: processed\n  };\n  let flipped = 0;\n  const toBeRenamed = {};\n\n  function shouldProcess(node, result) {\n    if (!node[processed]) {\n      let prevent = false;\n      $YmdI$var$state.walk(current => {\n        // check if current directive is expecting this node\n        if (!current.metadata.blacklist && current.directive.expect[node.type]) {\n          // perform action and prevent further processing if result equals true\n          if (current.directive.begin(node, current.metadata, context)) {\n            prevent = true;\n          } // if should end? end it.\n\n\n          if (current.metadata.end && current.directive.end(node, current.metadata, context)) {\n            $YmdI$var$state.pop(current);\n          }\n        }\n      });\n      node[processed] = true;\n      return !prevent;\n    }\n\n    return false;\n  }\n\n  return {\n    postcssPlugin: 'rtlcss',\n\n    Once(root, {\n      result\n    }) {\n      context.config.hooks.pre(root, $YmdI$var$postcss);\n      shouldProcess(root, result);\n    },\n\n    Rule(node, {\n      result\n    }) {\n      if (shouldProcess(node, result)) {\n        // new rule, reset flipped decl count to zero\n        flipped = 0;\n      }\n    },\n\n    AtRule(node, {\n      result\n    }) {\n      if (shouldProcess(node, result) && ( // @rules requires url flipping only\n      context.config.processUrls === true || context.config.processUrls.atrule === true)) {\n        const params = context.util.applyStringMap(node.params, true);\n        node.params = params;\n      }\n    },\n\n    Comment(node, {\n      result\n    }) {\n      if (shouldProcess(node, result)) {\n        $YmdI$var$state.parse(node, result, current => {\n          let push = true;\n\n          if (current.directive === null) {\n            current.preserve = !context.config.clean;\n            context.util.each(context.config.plugins, plugin => {\n              const blacklist = context.config.blacklist[plugin.name];\n\n              if (blacklist && blacklist[current.metadata.name] === true) {\n                current.metadata.blacklist = true;\n\n                if (current.metadata.end) {\n                  push = false;\n                }\n\n                if (current.metadata.begin) {\n                  result.warn(`directive \"${plugin.name}.${current.metadata.name}\" is blacklisted.`, {\n                    node: current.source\n                  });\n                } // break each\n\n\n                return false;\n              }\n\n              current.directive = plugin.directives.control[current.metadata.name];\n\n              if (current.directive) {\n                // break each\n                return false;\n              }\n            });\n          }\n\n          if (current.directive) {\n            if (!current.metadata.begin && current.metadata.end) {\n              if (current.directive.end(node, current.metadata, context)) {\n                $YmdI$var$state.pop(current);\n              }\n\n              push = false;\n            } else if (current.directive.expect.self && current.directive.begin(node, current.metadata, context) && current.metadata.end && current.directive.end(node, current.metadata, context)) {\n              push = false;\n            }\n          } else if (!current.metadata.blacklist) {\n            push = false;\n            result.warn(`unsupported directive \"${current.metadata.name}\".`, {\n              node: current.source\n            });\n          }\n\n          return push;\n        });\n      }\n    },\n\n    Declaration(node, {\n      result\n    }) {\n      if (shouldProcess(node, result)) {\n        // if broken by a matching value directive .. break\n        if (!context.util.each(context.config.plugins, plugin => {\n          return context.util.each(plugin.directives.value, directive => {\n            const hasRawValue = node.raws.value && node.raws.value.raw;\n            const expr = context.util.regexDirective(directive.name);\n\n            if (expr.test(`${node.raws.between}${hasRawValue ? node.raws.value.raw : ''}${node.important && node.raws.important ? node.raws.important : ''}`)) {\n              expr.lastIndex = 0;\n\n              if (directive.action(node, expr, context)) {\n                if (context.config.clean) {\n                  node.raws.between = context.util.trimDirective(node.raws.between);\n\n                  if (node.important && node.raws.important) {\n                    node.raws.important = context.util.trimDirective(node.raws.important);\n                  }\n\n                  if (hasRawValue) {\n                    node.value = node.raws.value.raw = context.util.trimDirective(node.raws.value.raw);\n                  }\n                }\n\n                flipped++; // break\n\n                return false;\n              }\n            }\n          });\n        })) return; // loop over all plugins/property processors\n\n        context.util.each(context.config.plugins, plugin => {\n          return context.util.each(plugin.processors, processor => {\n            const alias = context.config.aliases[node.prop];\n\n            if ((alias || node.prop).match(processor.expr)) {\n              const raw = node.raws.value && node.raws.value.raw ? node.raws.value.raw : node.value;\n              const state = context.util.saveComments(raw);\n\n              if (context.config.processEnv) {\n                state.value = context.util.swap(state.value, 'safe-area-inset-left', 'safe-area-inset-right', {\n                  ignoreCase: false\n                });\n              }\n\n              const pair = processor.action(node.prop, state.value, context);\n              state.value = pair.value;\n              pair.value = context.util.restoreComments(state);\n\n              if (!alias && pair.prop !== node.prop || pair.value !== raw) {\n                flipped++;\n                node.prop = pair.prop;\n                node.value = pair.value;\n              } // match found, break\n\n\n              return false;\n            }\n          });\n        }); // if last decl, apply auto rename\n        // decl. may be found inside @rules\n\n        if (context.config.autoRename && !flipped && node.parent.type === 'rule' && context.util.isLastOfType(node)) {\n          const renamed = context.util.applyStringMap(node.parent.selector);\n\n          if (context.config.autoRenameStrict === true) {\n            const pair = toBeRenamed[renamed];\n\n            if (pair) {\n              pair.selector = node.parent.selector;\n              node.parent.selector = renamed;\n            } else {\n              toBeRenamed[node.parent.selector] = node.parent;\n            }\n          } else {\n            node.parent.selector = renamed;\n          }\n        }\n      }\n    },\n\n    OnceExit(root, {\n      result\n    }) {\n      $YmdI$var$state.walk(item => {\n        result.warn(`unclosed directive \"${item.metadata.name}\".`, {\n          node: item.source\n        });\n      });\n\n      for (const key of Object.keys(toBeRenamed)) {\n        result.warn('renaming skipped due to lack of a matching pair.', {\n          node: toBeRenamed[key]\n        });\n      }\n\n      context.config.hooks.post(root, $YmdI$var$postcss);\n    }\n\n  };\n};\n\n$YmdI$exports.postcss = true;\n/**\r\n * Creates a new RTLCSS instance, process the input and return its result.\r\n * @param {String}  css  A string containing input CSS.\r\n * @param {Object}  options  An object containing RTLCSS settings.\r\n * @param {Object|Array}  plugins An array containing a list of RTLCSS plugins or a single RTLCSS plugin.\r\n * @param {Object}  hooks An object containing pre/post hooks.\r\n * @returns {String} A string contining the RTLed css.\r\n */\n\n$YmdI$exports.process = function (css, options, plugins, hooks) {\n  return $YmdI$var$postcss([this(options, plugins, hooks)]).process(css).css;\n};\n/**\r\n * Creates a new instance of RTLCSS using the passed configuration object\r\n * @param {Object}  config  An object containing RTLCSS options, plugins and hooks.\r\n * @returns {Object}  A new RTLCSS instance.\r\n */\n\n\n$YmdI$exports.configure = function (config) {\n  config = config || {};\n  return $YmdI$var$postcss([this(config.options, config.plugins, config.hooks)]);\n};"},"sourceMaps":null,"error":null,"hash":"48869fc4846f374bf0832e6d396c84a4","cacheData":{"env":{},"imports":{"$require$postcss":["postcss","*"],"$require$./state.js":["./state.js","*"],"$require$./config.js":["./config.js","*"],"$require$./util.js":["./util.js","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}