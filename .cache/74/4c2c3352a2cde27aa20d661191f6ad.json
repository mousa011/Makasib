{"id":"rWIt","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/package.json","includedInParent":true,"mtime":499162500000},{"name":"source-map-js","loc":{"line":3,"column":56},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/map-generator.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"path","loc":{"line":4,"column":50},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/map-generator.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"url","loc":{"line":5,"column":32},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/map-generator.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"buffer","parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/map-generator.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"generated":{"js":"var $rWIt$exports = {};\nvar $rWIt$var$Buffer = $parcel$require(\"rWIt\", \"buffer\").Buffer;\n\nfunction $rWIt$var$_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = $rWIt$var$_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction $rWIt$var$_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return $rWIt$var$_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $rWIt$var$_arrayLikeToArray(o, minLen); }\n\nfunction $rWIt$var$_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction $rWIt$var$_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction $rWIt$var$_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction $rWIt$var$_createClass(Constructor, protoProps, staticProps) { if (protoProps) $rWIt$var$_defineProperties(Constructor.prototype, protoProps); if (staticProps) $rWIt$var$_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar $rWIt$var$_require = $parcel$require(\"rWIt\", \"source-map-js\"),\n    $rWIt$var$SourceMapConsumer = $rWIt$var$_require.SourceMapConsumer,\n    $rWIt$var$SourceMapGenerator = $rWIt$var$_require.SourceMapGenerator;\nvar $rWIt$var$_require2 = $parcel$require(\"rWIt\", \"path\"),\n    $rWIt$var$dirname = $rWIt$var$_require2.dirname,\n    $rWIt$var$resolve = $rWIt$var$_require2.resolve,\n    $rWIt$var$relative = $rWIt$var$_require2.relative,\n    $rWIt$var$sep = $rWIt$var$_require2.sep;\nvar $rWIt$var$_require3 = $parcel$require(\"rWIt\", \"url\"),\n    $rWIt$var$pathToFileURL = $rWIt$var$_require3.pathToFileURL;\nvar $rWIt$var$sourceMapAvailable = Boolean($rWIt$var$SourceMapConsumer && $rWIt$var$SourceMapGenerator);\nvar $rWIt$var$pathAvailable = Boolean($rWIt$var$dirname && $rWIt$var$resolve && $rWIt$var$relative && $rWIt$var$sep);\n\nvar $rWIt$var$MapGenerator = /*#__PURE__*/function () {\n  function MapGenerator(stringify, root, opts) {\n    $rWIt$var$_classCallCheck(this, MapGenerator);\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n  }\n\n  $rWIt$var$_createClass(MapGenerator, [{\n    key: \"isMap\",\n    value: function isMap() {\n      if (typeof this.opts.map !== 'undefined') {\n        return !!this.opts.map;\n      }\n\n      return this.previous().length > 0;\n    }\n  }, {\n    key: \"previous\",\n    value: function previous() {\n      var _this = this;\n\n      if (!this.previousMaps) {\n        this.previousMaps = [];\n        this.root.walk(function (node) {\n          if (node.source && node.source.input.map) {\n            var map = node.source.input.map;\n\n            if (!_this.previousMaps.includes(map)) {\n              _this.previousMaps.push(map);\n            }\n          }\n        });\n      }\n\n      return this.previousMaps;\n    }\n  }, {\n    key: \"isInline\",\n    value: function isInline() {\n      if (typeof this.mapOpts.inline !== 'undefined') {\n        return this.mapOpts.inline;\n      }\n\n      var annotation = this.mapOpts.annotation;\n\n      if (typeof annotation !== 'undefined' && annotation !== true) {\n        return false;\n      }\n\n      if (this.previous().length) {\n        return this.previous().some(function (i) {\n          return i.inline;\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"isSourcesContent\",\n    value: function isSourcesContent() {\n      if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n        return this.mapOpts.sourcesContent;\n      }\n\n      if (this.previous().length) {\n        return this.previous().some(function (i) {\n          return i.withContent();\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"clearAnnotation\",\n    value: function clearAnnotation() {\n      if (this.mapOpts.annotation === false) return;\n      var node;\n\n      for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i];\n        if (node.type !== 'comment') continue;\n\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i);\n        }\n      }\n    }\n  }, {\n    key: \"setSourcesContent\",\n    value: function setSourcesContent() {\n      var _this2 = this;\n\n      var already = {};\n      this.root.walk(function (node) {\n        if (node.source) {\n          var from = node.source.input.from;\n\n          if (from && !already[from]) {\n            already[from] = true;\n\n            _this2.map.setSourceContent(_this2.toUrl(_this2.path(from)), node.source.input.css);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"applyPrevMaps\",\n    value: function applyPrevMaps() {\n      var _iterator = $rWIt$var$_createForOfIteratorHelper(this.previous()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prev = _step.value;\n          var from = this.toUrl(this.path(prev.file));\n          var root = prev.root || $rWIt$var$dirname(prev.file);\n          var map = void 0;\n\n          if (this.mapOpts.sourcesContent === false) {\n            map = new $rWIt$var$SourceMapConsumer(prev.text);\n\n            if (map.sourcesContent) {\n              map.sourcesContent = map.sourcesContent.map(function () {\n                return null;\n              });\n            }\n          } else {\n            map = prev.consumer();\n          }\n\n          this.map.applySourceMap(map, from, this.toUrl(this.path(root)));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"isAnnotation\",\n    value: function isAnnotation() {\n      if (this.isInline()) {\n        return true;\n      }\n\n      if (typeof this.mapOpts.annotation !== 'undefined') {\n        return this.mapOpts.annotation;\n      }\n\n      if (this.previous().length) {\n        return this.previous().some(function (i) {\n          return i.annotation;\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64(str) {\n      if ($rWIt$var$Buffer) {\n        return $rWIt$var$Buffer.from(str).toString('base64');\n      } else {\n        // istanbul ignore next\n        return window.btoa(unescape(encodeURIComponent(str)));\n      }\n    }\n  }, {\n    key: \"addAnnotation\",\n    value: function addAnnotation() {\n      var content;\n\n      if (this.isInline()) {\n        content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n      } else if (typeof this.mapOpts.annotation === 'string') {\n        content = this.mapOpts.annotation;\n      } else if (typeof this.mapOpts.annotation === 'function') {\n        content = this.mapOpts.annotation(this.opts.to, this.root);\n      } else {\n        content = this.outputFile() + '.map';\n      }\n\n      var eol = '\\n';\n      if (this.css.includes('\\r\\n')) eol = '\\r\\n';\n      this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n    }\n  }, {\n    key: \"outputFile\",\n    value: function outputFile() {\n      if (this.opts.to) {\n        return this.path(this.opts.to);\n      }\n\n      if (this.opts.from) {\n        return this.path(this.opts.from);\n      }\n\n      return 'to.css';\n    }\n  }, {\n    key: \"generateMap\",\n    value: function generateMap() {\n      this.generateString();\n      if (this.isSourcesContent()) this.setSourcesContent();\n      if (this.previous().length > 0) this.applyPrevMaps();\n      if (this.isAnnotation()) this.addAnnotation();\n\n      if (this.isInline()) {\n        return [this.css];\n      }\n\n      return [this.css, this.map];\n    }\n  }, {\n    key: \"path\",\n    value: function path(file) {\n      if (file.indexOf('<') === 0) return file;\n      if (/^\\w+:\\/\\//.test(file)) return file;\n      if (this.mapOpts.absolute) return file;\n      var from = this.opts.to ? $rWIt$var$dirname(this.opts.to) : '.';\n\n      if (typeof this.mapOpts.annotation === 'string') {\n        from = $rWIt$var$dirname($rWIt$var$resolve(from, this.mapOpts.annotation));\n      }\n\n      file = $rWIt$var$relative(from, file);\n      return file;\n    }\n  }, {\n    key: \"toUrl\",\n    value: function toUrl(path) {\n      if ($rWIt$var$sep === '\\\\') {\n        // istanbul ignore next\n        path = path.replace(/\\\\/g, '/');\n      }\n\n      return encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n    }\n  }, {\n    key: \"sourcePath\",\n    value: function sourcePath(node) {\n      if (this.mapOpts.from) {\n        return this.toUrl(this.mapOpts.from);\n      } else if (this.mapOpts.absolute) {\n        if ($rWIt$var$pathToFileURL) {\n          return $rWIt$var$pathToFileURL(node.source.input.from).toString();\n        } else {\n          // istanbul ignore next\n          throw new Error('`map.absolute` option is not available in this PostCSS build');\n        }\n      } else {\n        return this.toUrl(this.path(node.source.input.from));\n      }\n    }\n  }, {\n    key: \"generateString\",\n    value: function generateString() {\n      var _this3 = this;\n\n      this.css = '';\n      this.map = new $rWIt$var$SourceMapGenerator({\n        file: this.outputFile()\n      });\n      var line = 1;\n      var column = 1;\n      var noSource = '<no source>';\n      var mapping = {\n        source: '',\n        generated: {\n          line: 0,\n          column: 0\n        },\n        original: {\n          line: 0,\n          column: 0\n        }\n      };\n      var lines, last;\n      this.stringify(this.root, function (str, node, type) {\n        _this3.css += str;\n\n        if (node && type !== 'end') {\n          mapping.generated.line = line;\n          mapping.generated.column = column - 1;\n\n          if (node.source && node.source.start) {\n            mapping.source = _this3.sourcePath(node);\n            mapping.original.line = node.source.start.line;\n            mapping.original.column = node.source.start.column - 1;\n\n            _this3.map.addMapping(mapping);\n          } else {\n            mapping.source = noSource;\n            mapping.original.line = 1;\n            mapping.original.column = 0;\n\n            _this3.map.addMapping(mapping);\n          }\n        }\n\n        lines = str.match(/\\n/g);\n\n        if (lines) {\n          line += lines.length;\n          last = str.lastIndexOf('\\n');\n          column = str.length - last;\n        } else {\n          column += str.length;\n        }\n\n        if (node && type !== 'start') {\n          var p = node.parent || {\n            raws: {}\n          };\n\n          if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n            if (node.source && node.source.end) {\n              mapping.source = _this3.sourcePath(node);\n              mapping.original.line = node.source.end.line;\n              mapping.original.column = node.source.end.column - 1;\n              mapping.generated.line = line;\n              mapping.generated.column = column - 2;\n\n              _this3.map.addMapping(mapping);\n            } else {\n              mapping.source = noSource;\n              mapping.original.line = 1;\n              mapping.original.column = 0;\n              mapping.generated.line = line;\n              mapping.generated.column = column - 1;\n\n              _this3.map.addMapping(mapping);\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      this.clearAnnotation();\n\n      if ($rWIt$var$pathAvailable && $rWIt$var$sourceMapAvailable && this.isMap()) {\n        return this.generateMap();\n      }\n\n      var result = '';\n      this.stringify(this.root, function (i) {\n        result += i;\n      });\n      return [result];\n    }\n  }]);\n  return MapGenerator;\n}();\n\n$rWIt$exports = $rWIt$var$MapGenerator;"},"sourceMaps":null,"error":null,"hash":"4370027a8374ea59f6a145de8b6032d7","cacheData":{"env":{},"imports":{"$require$source-map-js":["source-map-js","*"],"$require$path":["path","*"],"$require$url":["url","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}