{"id":"TL5X","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/usr/local/lib/node_modules/parcel-bundler/node_modules/base64-js/package.json","includedInParent":true,"mtime":1636490470387}],"generated":{"js":"var $TL5X$exports = {};\nvar $TL5X$export$byteLength = $TL5X$var$byteLength;\n$TL5X$exports.byteLength = $TL5X$export$byteLength;\nvar $TL5X$export$toByteArray = $TL5X$var$toByteArray;\n$TL5X$exports.toByteArray = $TL5X$export$toByteArray;\nvar $TL5X$export$fromByteArray = $TL5X$var$fromByteArray;\n$TL5X$exports.fromByteArray = $TL5X$export$fromByteArray;\nvar $TL5X$var$lookup = [];\nvar $TL5X$var$revLookup = [];\nvar $TL5X$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar $TL5X$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var $TL5X$var$i = 0, $TL5X$var$len = $TL5X$var$code.length; $TL5X$var$i < $TL5X$var$len; ++$TL5X$var$i) {\n  $TL5X$var$lookup[$TL5X$var$i] = $TL5X$var$code[$TL5X$var$i];\n  $TL5X$var$revLookup[$TL5X$var$code.charCodeAt($TL5X$var$i)] = $TL5X$var$i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n$TL5X$var$revLookup['-'.charCodeAt(0)] = 62;\n$TL5X$var$revLookup['_'.charCodeAt(0)] = 63;\n\nfunction $TL5X$var$getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction $TL5X$var$byteLength(b64) {\n  var lens = $TL5X$var$getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction $TL5X$var$_byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction $TL5X$var$toByteArray(b64) {\n  var tmp;\n  var lens = $TL5X$var$getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new $TL5X$var$Arr($TL5X$var$_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = $TL5X$var$revLookup[b64.charCodeAt(i)] << 18 | $TL5X$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $TL5X$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $TL5X$var$revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = $TL5X$var$revLookup[b64.charCodeAt(i)] << 2 | $TL5X$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = $TL5X$var$revLookup[b64.charCodeAt(i)] << 10 | $TL5X$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $TL5X$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction $TL5X$var$tripletToBase64(num) {\n  return $TL5X$var$lookup[num >> 18 & 0x3F] + $TL5X$var$lookup[num >> 12 & 0x3F] + $TL5X$var$lookup[num >> 6 & 0x3F] + $TL5X$var$lookup[num & 0x3F];\n}\n\nfunction $TL5X$var$encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push($TL5X$var$tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction $TL5X$var$fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push($TL5X$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push($TL5X$var$lookup[tmp >> 2] + $TL5X$var$lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push($TL5X$var$lookup[tmp >> 10] + $TL5X$var$lookup[tmp >> 4 & 0x3F] + $TL5X$var$lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}"},"sourceMaps":null,"error":null,"hash":"847c024d6da20ff2e215d90a28e61645","cacheData":{"env":{},"imports":{},"exports":{"byteLength":"$TL5X$export$byteLength","toByteArray":"$TL5X$export$toByteArray","fromByteArray":"$TL5X$export$fromByteArray"},"wildcards":[],"sideEffects":true,"isCommonJS":true}}