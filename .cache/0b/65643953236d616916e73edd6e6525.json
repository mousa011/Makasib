{"id":"PWwn","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/rtlcss/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"var $PWwn$exports = {};\nlet $PWwn$var$config;\nlet $PWwn$var$tokenId = 0;\nconst $PWwn$var$CHAR_COMMENT_REPLACEMENT = '\\uFFFD'; // �\n\nconst $PWwn$var$CHAR_TOKEN_REPLACEMENT = '\\u00A4'; // ¤\n\nconst $PWwn$var$CHAR_TOKEN_START = '\\u00AB'; // «\n\nconst $PWwn$var$CHAR_TOKEN_END = '\\u00BB'; // »\n\nconst $PWwn$var$REGEX_COMMENT_REPLACEMENT = new RegExp($PWwn$var$CHAR_COMMENT_REPLACEMENT, 'ig');\nconst $PWwn$var$REGEX_TOKEN_REPLACEMENT = new RegExp($PWwn$var$CHAR_TOKEN_REPLACEMENT, 'ig');\nconst $PWwn$var$PATTERN_NUMBER = '\\\\-?(\\\\d*?\\\\.\\\\d+|\\\\d+)';\nconst $PWwn$var$PATTERN_NUMBER_WITH_CALC = '(calc' + $PWwn$var$CHAR_TOKEN_REPLACEMENT + ')|(' + $PWwn$var$PATTERN_NUMBER + ')(?!d\\\\()';\nconst $PWwn$var$PATTERN_TOKEN = $PWwn$var$CHAR_TOKEN_START + '\\\\d+:\\\\d+' + $PWwn$var$CHAR_TOKEN_END; // «offset:index»\n\nconst $PWwn$var$PATTERN_TOKEN_WITH_NAME = '\\\\w*?' + $PWwn$var$CHAR_TOKEN_START + '\\\\d+:\\\\d+' + $PWwn$var$CHAR_TOKEN_END; // «offset:index»\n\nconst $PWwn$var$REGEX_COMMENT = /\\/\\*[^]*?\\*\\//igm; // non-greedy\n\nconst $PWwn$var$REGEX_DIRECTIVE = /\\/\\*\\s*(?:!)?\\s*rtl:[^]*?\\*\\//img;\nconst $PWwn$var$REGEX_ESCAPE = /[.*+?^${}()|[\\]\\\\]/g;\nconst $PWwn$var$REGEX_FUNCTION = /\\([^()]+\\)/i;\nconst $PWwn$var$REGEX_HEX_COLOR = /#[a-f0-9]{3,6}/ig;\nconst $PWwn$var$REGEX_CALC = /calc/;\nconst $PWwn$var$REGEX_TOKENS = new RegExp($PWwn$var$PATTERN_TOKEN, 'ig');\nconst $PWwn$var$REGEX_TOKENS_WITH_NAME = new RegExp($PWwn$var$PATTERN_TOKEN_WITH_NAME, 'ig');\nconst $PWwn$var$REGEX_COMPLEMENT = new RegExp($PWwn$var$PATTERN_NUMBER_WITH_CALC, 'i');\nconst $PWwn$var$REGEX_NEGATE_ALL = new RegExp($PWwn$var$PATTERN_NUMBER_WITH_CALC, 'ig');\nconst $PWwn$var$REGEX_NEGATE_ONE = new RegExp($PWwn$var$PATTERN_NUMBER_WITH_CALC, 'i');\nconst $PWwn$var$DEFAULT_STRING_MAP_OPTIONS = {\n  scope: '*',\n  ignoreCase: true\n};\n\nfunction $PWwn$var$compare(what, to, ignoreCase) {\n  return ignoreCase ? what.toLowerCase() === to.toLowerCase() : what === to;\n}\n\nfunction $PWwn$var$escapeRegExp(string) {\n  return string.replace($PWwn$var$REGEX_ESCAPE, '\\\\$&');\n}\n\n$PWwn$exports = {\n  extend(dest, src) {\n    if (typeof dest === 'undefined' || typeof dest !== 'object') {\n      dest = {};\n    }\n\n    for (const prop in src) {\n      if (!Object.prototype.hasOwnProperty.call(dest, prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n\n    return dest;\n  },\n\n  swap(value, a, b, options) {\n    let expr = `${$PWwn$var$escapeRegExp(a)}|${$PWwn$var$escapeRegExp(b)}`;\n    options = options || $PWwn$var$DEFAULT_STRING_MAP_OPTIONS;\n    const greedy = Object.prototype.hasOwnProperty.call(options, 'greedy') ? options.greedy : $PWwn$var$config.greedy;\n    if (!greedy) expr = `\\\\b(${expr})\\\\b`;\n    const flags = options.ignoreCase ? 'img' : 'mg';\n    return value.replace(new RegExp(expr, flags), m => $PWwn$var$compare(m, a, options.ignoreCase) ? b : a);\n  },\n\n  swapLeftRight(value) {\n    return this.swap(value, 'left', 'right');\n  },\n\n  swapLtrRtl(value) {\n    return this.swap(value, 'ltr', 'rtl');\n  },\n\n  applyStringMap(value, isUrl) {\n    let result = value;\n\n    for (const map of $PWwn$var$config.stringMap) {\n      const options = this.extend(map.options, $PWwn$var$DEFAULT_STRING_MAP_OPTIONS);\n\n      if (options.scope === '*' || isUrl && options.scope === 'url' || !isUrl && options.scope === 'selector') {\n        if (Array.isArray(map.search) && Array.isArray(map.replace)) {\n          for (let mapIndex = 0; mapIndex < map.search.length; mapIndex++) {\n            result = this.swap(result, map.search[mapIndex], map.replace[mapIndex % map.search.length], options);\n          }\n        } else {\n          result = this.swap(result, map.search, map.replace, options);\n        }\n\n        if (map.exclusive === true) {\n          break;\n        }\n      }\n    }\n\n    return result;\n  },\n\n  negate(value) {\n    const state = this.saveTokens(value);\n    state.value = state.value.replace($PWwn$var$REGEX_NEGATE_ONE, num => {\n      return $PWwn$var$REGEX_TOKEN_REPLACEMENT.test(num) ? num.replace($PWwn$var$REGEX_TOKEN_REPLACEMENT, m => '(-1*' + m + ')') : Number.parseFloat(num) * -1;\n    });\n    return this.restoreTokens(state);\n  },\n\n  negateAll(value) {\n    const state = this.saveTokens(value);\n    state.value = state.value.replace($PWwn$var$REGEX_NEGATE_ALL, num => {\n      return $PWwn$var$REGEX_TOKEN_REPLACEMENT.test(num) ? num.replace($PWwn$var$REGEX_TOKEN_REPLACEMENT, m => '(-1*' + m + ')') : Number.parseFloat(num) * -1;\n    });\n    return this.restoreTokens(state);\n  },\n\n  complement(value) {\n    const state = this.saveTokens(value);\n    state.value = state.value.replace($PWwn$var$REGEX_COMPLEMENT, num => {\n      return $PWwn$var$REGEX_TOKEN_REPLACEMENT.test(num) ? num.replace($PWwn$var$REGEX_TOKEN_REPLACEMENT, m => '(100% - ' + m + ')') : 100 - Number.parseFloat(num);\n    });\n    return this.restoreTokens(state);\n  },\n\n  flipLength(value) {\n    return $PWwn$var$config.useCalc ? `calc(100% - ${value})` : value;\n  },\n\n  save(what, who, replacement, restorer, exclude) {\n    const state = {\n      value: who,\n      store: [],\n      replacement,\n      restorer\n    };\n    state.value = state.value.replace(what, c => {\n      if (exclude && c.match(exclude)) {\n        return c;\n      }\n\n      state.store.push(c);\n      return state.replacement;\n    });\n    return state;\n  },\n\n  restore(state) {\n    let index = 0;\n    const result = state.value.replace(state.restorer, () => {\n      return state.store[index++];\n    });\n    state.store.length = 0;\n    return result;\n  },\n\n  saveComments(value) {\n    return this.save($PWwn$var$REGEX_COMMENT, value, $PWwn$var$CHAR_COMMENT_REPLACEMENT, $PWwn$var$REGEX_COMMENT_REPLACEMENT);\n  },\n\n  restoreComments(state) {\n    return this.restore(state);\n  },\n\n  saveTokens(value, excludeCalc) {\n    return excludeCalc === true ? this.save($PWwn$var$REGEX_TOKENS_WITH_NAME, value, $PWwn$var$CHAR_TOKEN_REPLACEMENT, $PWwn$var$REGEX_TOKEN_REPLACEMENT, $PWwn$var$REGEX_CALC) : this.save($PWwn$var$REGEX_TOKENS, value, $PWwn$var$CHAR_TOKEN_REPLACEMENT, $PWwn$var$REGEX_TOKEN_REPLACEMENT);\n  },\n\n  restoreTokens(state) {\n    return this.restore(state);\n  },\n\n  guard(what, who, indexed) {\n    const state = {\n      value: who,\n      store: [],\n      offset: $PWwn$var$tokenId++,\n      token: $PWwn$var$CHAR_TOKEN_START + $PWwn$var$tokenId,\n      indexed: indexed === true\n    };\n\n    if (state.indexed === true) {\n      while (what.test(state.value)) {\n        state.value = state.value.replace(what, m => {\n          state.store.push(m);\n          return `${state.token}:${state.store.length}${$PWwn$var$CHAR_TOKEN_END}`;\n        });\n      }\n    } else {\n      state.value = state.value.replace(what, m => {\n        state.store.push(m);\n        return state.token + $PWwn$var$CHAR_TOKEN_END;\n      });\n    }\n\n    return state;\n  },\n\n  unguard(state, callback) {\n    if (state.indexed === true) {\n      const detokenizer = new RegExp('(\\\\w*?)' + state.token + ':(\\\\d+)' + $PWwn$var$CHAR_TOKEN_END, 'i');\n\n      while (detokenizer.test(state.value)) {\n        state.value = state.value.replace(detokenizer, (match, name, index) => {\n          const value = state.store[index - 1];\n          return typeof callback === 'function' ? name + callback(value, name) : name + value;\n        });\n      }\n\n      return state.value;\n    }\n\n    return state.value.replace(new RegExp('(\\\\w*?)' + state.token + $PWwn$var$CHAR_TOKEN_END, 'i'), (match, name) => {\n      const value = state.store.shift();\n      return typeof callback === 'function' ? name + callback(value, name) : name + value;\n    });\n  },\n\n  guardHexColors(value) {\n    return this.guard($PWwn$var$REGEX_HEX_COLOR, value, true);\n  },\n\n  unguardHexColors(state, callback) {\n    return this.unguard(state, callback);\n  },\n\n  guardFunctions(value) {\n    return this.guard($PWwn$var$REGEX_FUNCTION, value, true);\n  },\n\n  unguardFunctions(state, callback) {\n    return this.unguard(state, callback);\n  },\n\n  trimDirective(value) {\n    return value.replace($PWwn$var$REGEX_DIRECTIVE, '');\n  },\n\n  regexCache: {},\n\n  regexDirective(name) {\n    // /(?:\\/\\*(?:!)?rtl:ignore(?::)?)([^]*?)(?:\\*\\/)/img\n    this.regexCache[name] = this.regexCache[name] || new RegExp('(?:\\\\/\\\\*\\\\s*(?:!)?\\\\s*rtl:' + (name ? $PWwn$var$escapeRegExp(name) + '(?::)?' : '') + ')([^]*?)(?:\\\\*\\\\/)', 'img');\n    return this.regexCache[name];\n  },\n\n  regex(what, options) {\n    what = what || [];\n    let expression = '';\n\n    for (const exp of what) {\n      switch (exp) {\n        case 'percent':\n          expression += `|(${$PWwn$var$PATTERN_NUMBER}%)`;\n          break;\n\n        case 'length':\n          expression += `|(${$PWwn$var$PATTERN_NUMBER})(?:ex|ch|r?em|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc)?`;\n          break;\n\n        case 'number':\n          expression += `|(${$PWwn$var$PATTERN_NUMBER})`;\n          break;\n\n        case 'position':\n          expression += '|(left|center|right|top|bottom)';\n          break;\n\n        case 'calc':\n          expression += `|(calc${$PWwn$var$PATTERN_TOKEN})`;\n          break;\n      }\n    }\n\n    return new RegExp(expression.slice(1), options);\n  },\n\n  isLastOfType(node) {\n    let isLast = true;\n    let next = node.next();\n\n    while (next) {\n      if (next.type === node.type) {\n        isLast = false;\n        break;\n      }\n\n      next = next.next();\n    }\n\n    return isLast;\n  },\n\n  /**\r\n   * Simple breakable each: returning false in the callback will break the loop\r\n   * returns false if the loop was broken, otherwise true\r\n   */\n  each(array, callback) {\n    for (const element of array) {\n      if (callback(element) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\n$PWwn$exports.configure = function (configuration) {\n  $PWwn$var$config = configuration;\n  return this;\n};"},"sourceMaps":null,"error":null,"hash":"44301f21f01609287f4c43cbbf935e68","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}