{"id":"sfur","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/usr/local/lib/node_modules/parcel-bundler/node_modules/process/package.json","includedInParent":true,"mtime":1636490470133}],"generated":{"js":"\nvar $sfur$exports = {};\n// shim for using process in browser\nvar $sfur$var$process = $sfur$exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar $sfur$var$cachedSetTimeout;\nvar $sfur$var$cachedClearTimeout;\n\nfunction $sfur$var$defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction $sfur$var$defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      $sfur$var$cachedSetTimeout = setTimeout;\n    } else {\n      $sfur$var$cachedSetTimeout = $sfur$var$defaultSetTimout;\n    }\n  } catch (e) {\n    $sfur$var$cachedSetTimeout = $sfur$var$defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      $sfur$var$cachedClearTimeout = clearTimeout;\n    } else {\n      $sfur$var$cachedClearTimeout = $sfur$var$defaultClearTimeout;\n    }\n  } catch (e) {\n    $sfur$var$cachedClearTimeout = $sfur$var$defaultClearTimeout;\n  }\n})();\n\nfunction $sfur$var$runTimeout(fun) {\n  if ($sfur$var$cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if (($sfur$var$cachedSetTimeout === $sfur$var$defaultSetTimout || !$sfur$var$cachedSetTimeout) && setTimeout) {\n    $sfur$var$cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $sfur$var$cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return $sfur$var$cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return $sfur$var$cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction $sfur$var$runClearTimeout(marker) {\n  if ($sfur$var$cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if (($sfur$var$cachedClearTimeout === $sfur$var$defaultClearTimeout || !$sfur$var$cachedClearTimeout) && clearTimeout) {\n    $sfur$var$cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $sfur$var$cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return $sfur$var$cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return $sfur$var$cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar $sfur$var$queue = [];\nvar $sfur$var$draining = false;\nvar $sfur$var$currentQueue;\nvar $sfur$var$queueIndex = -1;\n\nfunction $sfur$var$cleanUpNextTick() {\n  if (!$sfur$var$draining || !$sfur$var$currentQueue) {\n    return;\n  }\n\n  $sfur$var$draining = false;\n\n  if ($sfur$var$currentQueue.length) {\n    $sfur$var$queue = $sfur$var$currentQueue.concat($sfur$var$queue);\n  } else {\n    $sfur$var$queueIndex = -1;\n  }\n\n  if ($sfur$var$queue.length) {\n    $sfur$var$drainQueue();\n  }\n}\n\nfunction $sfur$var$drainQueue() {\n  if ($sfur$var$draining) {\n    return;\n  }\n\n  var timeout = $sfur$var$runTimeout($sfur$var$cleanUpNextTick);\n  $sfur$var$draining = true;\n  var len = $sfur$var$queue.length;\n\n  while (len) {\n    $sfur$var$currentQueue = $sfur$var$queue;\n    $sfur$var$queue = [];\n\n    while (++$sfur$var$queueIndex < len) {\n      if ($sfur$var$currentQueue) {\n        $sfur$var$currentQueue[$sfur$var$queueIndex].run();\n      }\n    }\n\n    $sfur$var$queueIndex = -1;\n    len = $sfur$var$queue.length;\n  }\n\n  $sfur$var$currentQueue = null;\n  $sfur$var$draining = false;\n  $sfur$var$runClearTimeout(timeout);\n}\n\n$sfur$var$process.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  $sfur$var$queue.push(new $sfur$var$Item(fun, args));\n\n  if ($sfur$var$queue.length === 1 && !$sfur$var$draining) {\n    $sfur$var$runTimeout($sfur$var$drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction $sfur$var$Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\n$sfur$var$Item.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\n$sfur$var$process.title = 'browser';\n$sfur$var$process.env = {};\n$sfur$var$process.argv = [];\n$sfur$var$process.version = ''; // empty string to avoid regexp issues\n\n$sfur$var$process.versions = {};\n\nfunction $sfur$var$noop() {}\n\n$sfur$var$process.on = $sfur$var$noop;\n$sfur$var$process.addListener = $sfur$var$noop;\n$sfur$var$process.once = $sfur$var$noop;\n$sfur$var$process.off = $sfur$var$noop;\n$sfur$var$process.removeListener = $sfur$var$noop;\n$sfur$var$process.removeAllListeners = $sfur$var$noop;\n$sfur$var$process.emit = $sfur$var$noop;\n$sfur$var$process.prependListener = $sfur$var$noop;\n$sfur$var$process.prependOnceListener = $sfur$var$noop;\n\n$sfur$var$process.listeners = function (name) {\n  return [];\n};\n\n$sfur$var$process.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\n$sfur$var$process.cwd = function () {\n  return '/';\n};\n\n$sfur$var$process.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\n$sfur$var$process.umask = function () {\n  return 0;\n};"},"sourceMaps":null,"error":null,"hash":"c6e92d131e9850c38dec70e5d0a40aee","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}