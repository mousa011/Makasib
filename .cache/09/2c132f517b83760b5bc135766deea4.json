{"id":"Wbtw","dependencies":[{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/package.json","includedInParent":true,"mtime":1637421147719},{"name":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/package.json","includedInParent":true,"mtime":499162500000},{"name":"source-map-js","loc":{"line":3,"column":56},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/previous-map.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"fs","loc":{"line":4,"column":43},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/previous-map.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"path","loc":{"line":5,"column":32},"parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/previous-map.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"buffer","parent":"/Users/muhammadmousa/Desktop/my work/مكاسب/Makasib/node_modules/postcss/lib/previous-map.js","resolved":"/usr/local/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"generated":{"js":"var $Wbtw$exports = {};\nvar $Wbtw$var$Buffer = $parcel$require(\"Wbtw\", \"buffer\").Buffer;\n\nfunction $Wbtw$var$_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { $Wbtw$var$_typeof = function _typeof(obj) { return typeof obj; }; } else { $Wbtw$var$_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return $Wbtw$var$_typeof(obj); }\n\nfunction $Wbtw$var$_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction $Wbtw$var$_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction $Wbtw$var$_createClass(Constructor, protoProps, staticProps) { if (protoProps) $Wbtw$var$_defineProperties(Constructor.prototype, protoProps); if (staticProps) $Wbtw$var$_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar $Wbtw$var$_require = $parcel$require(\"Wbtw\", \"source-map-js\"),\n    $Wbtw$var$SourceMapConsumer = $Wbtw$var$_require.SourceMapConsumer,\n    $Wbtw$var$SourceMapGenerator = $Wbtw$var$_require.SourceMapGenerator;\nvar $Wbtw$var$_require2 = $parcel$require(\"Wbtw\", \"fs\"),\n    $Wbtw$var$existsSync = $Wbtw$var$_require2.existsSync,\n    $Wbtw$var$readFileSync = $Wbtw$var$_require2.readFileSync;\nvar $Wbtw$var$_require3 = $parcel$require(\"Wbtw\", \"path\"),\n    $Wbtw$var$dirname = $Wbtw$var$_require3.dirname,\n    $Wbtw$var$join = $Wbtw$var$_require3.join;\n\nfunction $Wbtw$var$fromBase64(str) {\n  if ($Wbtw$var$Buffer) {\n    return $Wbtw$var$Buffer.from(str, 'base64').toString();\n  } else {\n    // istanbul ignore next\n    return window.atob(str);\n  }\n}\n\nvar $Wbtw$var$PreviousMap = /*#__PURE__*/function () {\n  function PreviousMap(css, opts) {\n    $Wbtw$var$_classCallCheck(this, PreviousMap);\n    if (opts.map === false) return;\n    this.loadAnnotation(css);\n    this.inline = this.startWith(this.annotation, 'data:');\n    var prev = opts.map ? opts.map.prev : undefined;\n    var text = this.loadMap(opts.from, prev);\n\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from;\n    }\n\n    if (this.mapFile) this.root = $Wbtw$var$dirname(this.mapFile);\n    if (text) this.text = text;\n  }\n\n  $Wbtw$var$_createClass(PreviousMap, [{\n    key: \"consumer\",\n    value: function consumer() {\n      if (!this.consumerCache) {\n        this.consumerCache = new $Wbtw$var$SourceMapConsumer(this.text);\n      }\n\n      return this.consumerCache;\n    }\n  }, {\n    key: \"withContent\",\n    value: function withContent() {\n      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    }\n  }, {\n    key: \"startWith\",\n    value: function startWith(string, start) {\n      if (!string) return false;\n      return string.substr(0, start.length) === start;\n    }\n  }, {\n    key: \"getAnnotationURL\",\n    value: function getAnnotationURL(sourceMapString) {\n      return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim();\n    }\n  }, {\n    key: \"loadAnnotation\",\n    value: function loadAnnotation(css) {\n      var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n      if (!comments) return; // sourceMappingURLs from comments, strings, etc.\n\n      var start = css.lastIndexOf(comments.pop());\n      var end = css.indexOf('*/', start);\n\n      if (start > -1 && end > -1) {\n        // Locate the last sourceMappingURL to avoid pickin\n        this.annotation = this.getAnnotationURL(css.substring(start, end));\n      }\n    }\n  }, {\n    key: \"decodeInline\",\n    value: function decodeInline(text) {\n      var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n      var baseUri = /^data:application\\/json;base64,/;\n      var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n      var uri = /^data:application\\/json,/;\n\n      if (charsetUri.test(text) || uri.test(text)) {\n        return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n      }\n\n      if (baseCharsetUri.test(text) || baseUri.test(text)) {\n        return $Wbtw$var$fromBase64(text.substr(RegExp.lastMatch.length));\n      }\n\n      var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n      throw new Error('Unsupported source map encoding ' + encoding);\n    }\n  }, {\n    key: \"loadFile\",\n    value: function loadFile(path) {\n      this.root = $Wbtw$var$dirname(path);\n\n      if ($Wbtw$var$existsSync(path)) {\n        this.mapFile = path;\n        return $Wbtw$var$readFileSync(path, 'utf-8').toString().trim();\n      }\n    }\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(file, prev) {\n      if (prev === false) return false;\n\n      if (prev) {\n        if (typeof prev === 'string') {\n          return prev;\n        } else if (typeof prev === 'function') {\n          var prevPath = prev(file);\n\n          if (prevPath) {\n            var map = this.loadFile(prevPath);\n\n            if (!map) {\n              throw new Error('Unable to load previous source map: ' + prevPath.toString());\n            }\n\n            return map;\n          }\n        } else if (prev instanceof $Wbtw$var$SourceMapConsumer) {\n          return $Wbtw$var$SourceMapGenerator.fromSourceMap(prev).toString();\n        } else if (prev instanceof $Wbtw$var$SourceMapGenerator) {\n          return prev.toString();\n        } else if (this.isMap(prev)) {\n          return JSON.stringify(prev);\n        } else {\n          throw new Error('Unsupported previous source map format: ' + prev.toString());\n        }\n      } else if (this.inline) {\n        return this.decodeInline(this.annotation);\n      } else if (this.annotation) {\n        var _map = this.annotation;\n        if (file) _map = $Wbtw$var$join($Wbtw$var$dirname(file), _map);\n        return this.loadFile(_map);\n      }\n    }\n  }, {\n    key: \"isMap\",\n    value: function isMap(map) {\n      if ($Wbtw$var$_typeof(map) !== 'object') return false;\n      return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);\n    }\n  }]);\n  return PreviousMap;\n}();\n\n$Wbtw$exports = $Wbtw$var$PreviousMap;\n$Wbtw$var$PreviousMap.default = $Wbtw$var$PreviousMap;"},"sourceMaps":null,"error":null,"hash":"a23a3de7aa2479a07bb772913641f8b5","cacheData":{"env":{},"imports":{"$require$source-map-js":["source-map-js","*"],"$require$fs":["fs","*"],"$require$path":["path","*"],"$require$buffer":["buffer","*"]},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}